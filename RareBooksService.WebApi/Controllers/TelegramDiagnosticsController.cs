using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Configuration;
using System.Text.Json;
using System.Text;
using System.IO;
using RareBooksService.WebApi.Services;
using RareBooksService.Common.Models.Telegram;
using RareBooksService.Data;
using RareBooksService.Common.Models;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.DependencyInjection;
using SystemFile = System.IO.File;

namespace RareBooksService.WebApi.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    [AllowAnonymous] // –î–ª—è —É–¥–æ–±—Å—Ç–≤–∞ –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∏, –º–æ–∂–Ω–æ –ø–æ—Ç–æ–º –¥–æ–±–∞–≤–∏—Ç—å –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—é
    public class TelegramDiagnosticsController : ControllerBase
    {
        private readonly IConfiguration _config;
        private readonly ILogger<TelegramDiagnosticsController> _logger;
        private readonly ITelegramNotificationService _telegramService;
        private readonly HttpClient _httpClient;
        private readonly IServiceProvider _serviceProvider;

        public TelegramDiagnosticsController(
            IConfiguration config,
            ILogger<TelegramDiagnosticsController> logger,
            ITelegramNotificationService telegramService,
            HttpClient httpClient,
            IServiceProvider serviceProvider)
        {
            _config = config;
            _logger = logger;
            _telegramService = telegramService;
            _httpClient = httpClient;
            _serviceProvider = serviceProvider;
        }

        /// <summary>
        /// –ü–æ–ª–Ω–∞—è –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞ Telegram –±–æ—Ç–∞
        /// </summary>
        [HttpGet("full-check")]
        public async Task<IActionResult> FullDiagnostics()
        {
            var result = new
            {
                timestamp = DateTime.UtcNow,
                checks = new Dictionary<string, object>()
            };

            try
            {
                // 1. –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
                var token = _config["TelegramBot:Token"];
                result.checks["config"] = new
                {
                    hasToken = !string.IsNullOrEmpty(token),
                    tokenLength = token?.Length ?? 0,
                    tokenMasked = string.IsNullOrEmpty(token) ? "NOT_SET" : $"{token.Substring(0, Math.Min(10, token.Length))}***",
                    configSource = "appsettings.json"
                };

                // 2. –ü—Ä–æ–≤–µ—Ä–∫–∞ —á–µ—Ä–µ–∑ Telegram API
                if (!string.IsNullOrEmpty(token))
                {
                    try
                    {
                        var response = await _httpClient.GetStringAsync($"https://api.telegram.org/bot{token}/getMe");
                        var botInfo = JsonSerializer.Deserialize<JsonElement>(response);
                        
                        result.checks["telegram_api"] = new
                        {
                            status = "success",
                            botInfo = botInfo.GetProperty("result"),
                            raw_response = response
                        };
                    }
                    catch (Exception ex)
                    {
                        result.checks["telegram_api"] = new
                        {
                            status = "error",
                            error = ex.Message,
                            details = ex.ToString()
                        };
                    }

                    // 3. –ü—Ä–æ–≤–µ—Ä–∫–∞ webhook
                    try
                    {
                        var webhookResponse = await _httpClient.GetStringAsync($"https://api.telegram.org/bot{token}/getWebhookInfo");
                        var webhookInfo = JsonSerializer.Deserialize<JsonElement>(webhookResponse);
                        
                        result.checks["webhook"] = new
                        {
                            status = "success",
                            webhookInfo = webhookInfo.GetProperty("result"),
                            raw_response = webhookResponse
                        };
                    }
                    catch (Exception ex)
                    {
                        result.checks["webhook"] = new
                        {
                            status = "error",
                            error = ex.Message
                        };
                    }
                }
                else
                {
                    result.checks["telegram_api"] = new
                    {
                        status = "skipped",
                        reason = "No token configured"
                    };
                    result.checks["webhook"] = new
                    {
                        status = "skipped", 
                        reason = "No token configured"
                    };
                }

                // 4. –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–µ—Ä–≤–∏—Å–æ–≤
                result.checks["services"] = new
                {
                    telegramServiceRegistered = _telegramService != null,
                    serviceType = _telegramService?.GetType().Name ?? "null"
                };

                // 5. –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –∏–∑ —Ñ–∞–π–ª–∞
                try
                {
                    var appSettingsPath = Path.Combine(Directory.GetCurrentDirectory(), "appsettings.json");
                    if (SystemFile.Exists(appSettingsPath))
                    {
                        var configContent = await SystemFile.ReadAllTextAsync(appSettingsPath);
                        var configJson = JsonSerializer.Deserialize<JsonElement>(configContent);
                        
                        var hasTelegramSection = configJson.TryGetProperty("TelegramBot", out var telegramSection);
                        string tokenFromFile = "NOT_SET";
                        
                        if (hasTelegramSection && telegramSection.TryGetProperty("Token", out var tokenProp))
                        {
                            if (tokenProp.ValueKind == JsonValueKind.String)
                            {
                                var tokenValue = tokenProp.GetString();
                                tokenFromFile = !string.IsNullOrEmpty(tokenValue) 
                                    ? $"{tokenValue.Substring(0, Math.Min(10, tokenValue.Length))}***" 
                                    : "EMPTY";
                            }
                        }
                        
                        var hasTokenInFile = hasTelegramSection && telegramSection.TryGetProperty("Token", out _);
                        
                        result.checks["config_file"] = new
                        {
                            fileExists = true,
                            hasTelegramSection = hasTelegramSection,
                            hasTokenInFile = hasTokenInFile,
                            tokenFromFile = tokenFromFile
                        };
                    }
                    else
                    {
                        result.checks["config_file"] = new
                        {
                            fileExists = false,
                            path = appSettingsPath
                        };
                    }
                }
                catch (Exception ex)
                {
                    result.checks["config_file"] = new
                    {
                        status = "error",
                        error = ex.Message
                    };
                }

                return Ok(result);
            }
            catch (Exception ex)
            {
                return StatusCode(500, new
                {
                    error = "Diagnostic failed",
                    message = ex.Message,
                    details = ex.ToString(),
                    partialResult = result
                });
            }
        }

        /// <summary>
        /// –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è (—Ç—Ä–µ–±—É–µ—Ç chat_id)
        /// </summary>
        [HttpPost("test-send")]
        public async Task<IActionResult> TestSendMessage([FromBody] TestSendRequest request)
        {
            try
            {
                var token = _config["TelegramBot:Token"];
                if (string.IsNullOrEmpty(token))
                {
                    return BadRequest(new { error = "Token not configured" });
                }

                var payload = new
                {
                    chat_id = request.ChatId,
                    text = request.Message ?? "üîß –¢–µ—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∏ –±–æ—Ç–∞"
                };

                var jsonContent = JsonSerializer.Serialize(payload);
                var content = new StringContent(jsonContent, Encoding.UTF8, "application/json");

                var response = await _httpClient.PostAsync($"https://api.telegram.org/bot{token}/sendMessage", content);
                var responseText = await response.Content.ReadAsStringAsync();

                return Ok(new
                {
                    success = response.IsSuccessStatusCode,
                    statusCode = (int)response.StatusCode,
                    response = responseText,
                    request = payload
                });
            }
            catch (Exception ex)
            {
                return StatusCode(500, new
                {
                    error = "Test send failed",
                    message = ex.Message,
                    details = ex.ToString()
                });
            }
        }

        /// <summary>
        /// –£—Å—Ç–∞–Ω–æ–≤–∫–∞ webhook –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
        /// </summary>
        [HttpPost("setup-webhook")]
        public async Task<IActionResult> SetupWebhook([FromBody] SetupWebhookRequest request)
        {
            try
            {
                var token = _config["TelegramBot:Token"];
                if (string.IsNullOrEmpty(token))
                {
                    return BadRequest(new { error = "Token not configured" });
                }

                var webhookUrl = $"{request.BaseUrl}/api/telegram/webhook";
                
                var payload = new
                {
                    url = webhookUrl,
                    max_connections = 40,
                    allowed_updates = new[] { "message", "callback_query" }
                };

                var jsonContent = JsonSerializer.Serialize(payload);
                var content = new StringContent(jsonContent, Encoding.UTF8, "application/json");

                var response = await _httpClient.PostAsync($"https://api.telegram.org/bot{token}/setWebhook", content);
                var responseText = await response.Content.ReadAsStringAsync();

                return Ok(new
                {
                    success = response.IsSuccessStatusCode,
                    statusCode = (int)response.StatusCode,
                    response = responseText,
                    webhookUrl = webhookUrl,
                    request = payload
                });
            }
            catch (Exception ex)
            {
                return StatusCode(500, new
                {
                    error = "Webhook setup failed",
                    message = ex.Message,
                    details = ex.ToString()
                });
            }
        }

        /// <summary>
        /// –£–¥–∞–ª–µ–Ω–∏–µ webhook –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
        /// </summary>
        [HttpPost("delete-webhook")]
        public async Task<IActionResult> DeleteWebhook()
        {
            try
            {
                var token = _config["TelegramBot:Token"];
                if (string.IsNullOrEmpty(token))
                {
                    return BadRequest(new { error = "Token not configured" });
                }

                var response = await _httpClient.PostAsync($"https://api.telegram.org/bot{token}/deleteWebhook", 
                    new StringContent("{}", Encoding.UTF8, "application/json"));
                var responseText = await response.Content.ReadAsStringAsync();

                return Ok(new
                {
                    success = response.IsSuccessStatusCode,
                    statusCode = (int)response.StatusCode,
                    response = responseText
                });
            }
            catch (Exception ex)
            {
                return StatusCode(500, new
                {
                    error = "Webhook deletion failed",
                    message = ex.Message,
                    details = ex.ToString()
                });
            }
        }

        /// <summary>
        /// –ü–æ–ª—É—á–µ–Ω–∏–µ –ª–æ–≥–æ–≤ –æ—à–∏–±–æ–∫
        /// </summary>
        /*[HttpGet("logs")]
        public async Task<IActionResult> GetLogs([FromQuery] int hours = 1)
        {
            try
            {
                var logs = new List<string>();
                var sinceTime = DateTime.UtcNow.AddHours(-hours);

                // –ü–æ–ø—Ä–æ–±—É–µ–º –Ω–∞–π—Ç–∏ —Ñ–∞–π–ª—ã –ª–æ–≥–æ–≤ –≤ –æ–±—ã—á–Ω—ã—Ö –º–µ—Å—Ç–∞—Ö
                var possibleLogPaths = new[]
                {
                    Path.Combine(Directory.GetCurrentDirectory(), "logs"),
                    Path.Combine(Directory.GetCurrentDirectory(), "Logs"),
                    "/var/log/rarebooksservice",
                    "/home/www/logs",
                    "/var/www/logs"
                };

                foreach (var logDir in possibleLogPaths)
                {
                    if (Directory.Exists(logDir))
                    {
                        var logFiles = Directory.GetFiles(logDir, "*.log")
                            .Concat(Directory.GetFiles(logDir, "*.txt"))
                            .Where(f => SystemFile.GetLastWriteTime(f) > sinceTime)
                            .OrderByDescending(f => SystemFile.GetLastWriteTime(f))
                            .Take(3);

                        foreach (var file in logFiles)
                        {
                            try
                            {
                                var lines = await SystemFile.ReadAllLinesAsync(file);
                                var recentLines = lines
                                    .Where(line => line.Contains("WEBHOOK") || 
                                                  line.Contains("Telegram") || 
                                                  line.Contains("400") ||
                                                  line.Contains("ERROR"))
                                    .TakeLast(20);
                                
                                if (recentLines.Any())
                                {
                                    logs.Add($"=== {Path.GetFileName(file)} ===");
                                    logs.AddRange(recentLines);
                                    logs.Add("");
                                }
                            }
                            catch (Exception ex)
                            {
                                logs.Add($"Error reading {file}: {ex.Message}");
                            }
                        }
                    }
                }

                return Ok(new
                {
                    timestamp = DateTime.UtcNow,
                    timeRange = $"Last {hours} hours",
                    logEntries = logs,
                    totalEntries = logs.Count,
                    searchedPaths = possibleLogPaths
                });
            }
            catch (Exception ex)
            {
                return StatusCode(500, new
                {
                    error = "Log reading failed",
                    message = ex.Message,
                    details = ex.ToString()
                });
            }
        }*/

        /// <summary>
        /// –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–∏—Å—Ç–µ–º—ã —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π —Å —Ä–µ–∞–ª—å–Ω—ã–º–∏ –∞–∫—Ç–∏–≤–Ω—ã–º–∏ –ª–æ—Ç–∞–º–∏
        /// </summary>
        [HttpPost("test-notifications")]
        public async Task<IActionResult> TestNotifications([FromBody] TestNotificationsRequest request)
        {
            try
            {
                _logger.LogInformation("–ù–∞—á–∏–Ω–∞–µ–º —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–∏—Å—Ç–µ–º—ã —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π...");

                using var scope = _serviceProvider.CreateScope();
                var usersContext = scope.ServiceProvider.GetRequiredService<UsersDbContext>();
                var booksContext = scope.ServiceProvider.GetRequiredService<BooksDbContext>();
                var bookNotificationService = scope.ServiceProvider.GetRequiredService<IBookNotificationService>();

                // –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ –∞–∫—Ç–∏–≤–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π
                var activePreferences = await usersContext.UserNotificationPreferences
                    .Include(np => np.User)
                    .Where(np => np.IsEnabled && !string.IsNullOrEmpty(np.User.TelegramId))
                    .ToListAsync();

                if (!activePreferences.Any())
                {
                    return Ok(new 
                    { 
                        success = false, 
                        message = "–ù–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π —Å –∞–∫—Ç–∏–≤–Ω—ã–º–∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞–º–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π –∏ Telegram ID",
                        details = new 
                        {
                            totalActivePreferences = 0,
                            usersWithTelegram = 0,
                            activeLotsFound = 0,
                            notificationsCreated = 0
                        }
                    });
                }

                _logger.LogInformation("–ù–∞–π–¥–µ–Ω–æ {Count} –∞–∫—Ç–∏–≤–Ω—ã—Ö –Ω–∞—Å—Ç—Ä–æ–µ–∫ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π", activePreferences.Count);

                // –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ –∞–∫—Ç–∏–≤–Ω—ã–µ –ª–æ—Ç—ã
                var now = DateTime.UtcNow;
                var activeLots = await booksContext.BooksInfo
                    .Include(b => b.Category)
                    .Where(b => b.EndDate > now)
                    .AsNoTracking()
                    .ToListAsync();

                if (!activeLots.Any())
                {
                    return Ok(new 
                    { 
                        success = false, 
                        message = "–ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –ª–æ—Ç–æ–≤ –Ω–∞ —Ç–æ—Ä–≥–∞—Ö",
                        details = new 
                        {
                            totalActivePreferences = activePreferences.Count,
                            usersWithTelegram = activePreferences.Count,
                            activeLotsFound = 0,
                            notificationsCreated = 0
                        }
                    });
                }

                _logger.LogInformation("–ù–∞–π–¥–µ–Ω–æ {Count} –∞–∫—Ç–∏–≤–Ω—ã—Ö –ª–æ—Ç–æ–≤", activeLots.Count);

                // –°–æ–±–∏—Ä–∞–µ–º –≤—Å–µ –ø–æ–¥—Ö–æ–¥—è—â–∏–µ –ª–æ—Ç—ã –¥–ª—è –≤—Å–µ—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
                var matchingBookIds = new HashSet<int>();
                var matchedCounts = new Dictionary<string, int>();

                foreach (var preference in activePreferences)
                {
                    var userMatchingBooks = FilterBooksByPreferences(activeLots, preference);
                    var userMatchingIds = userMatchingBooks.Select(b => b.Id).ToList();
                    
                    matchedCounts[preference.User.Email ?? preference.User.Id] = userMatchingIds.Count;
                    
                    foreach (var bookId in userMatchingIds)
                    {
                        matchingBookIds.Add(bookId);
                    }
                    
                    _logger.LogInformation("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {UserEmail}: –Ω–∞–π–¥–µ–Ω–æ {Count} –ø–æ–¥—Ö–æ–¥—è—â–∏—Ö –ª–æ—Ç–æ–≤", 
                        preference.User.Email ?? preference.User.Id, userMatchingIds.Count);
                }

                if (!matchingBookIds.Any())
                {
                    return Ok(new 
                    { 
                        success = false, 
                        message = "–ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –ª–æ—Ç–æ–≤, —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏—Ö –∫—Ä–∏—Ç–µ—Ä–∏—è–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π",
                        details = new 
                        {
                            totalActivePreferences = activePreferences.Count,
                            usersWithTelegram = activePreferences.Count,
                            activeLotsFound = activeLots.Count,
                            notificationsCreated = 0,
                            userMatches = matchedCounts
                        }
                    });
                }

                _logger.LogInformation("–í—Å–µ–≥–æ –Ω–∞–π–¥–µ–Ω–æ {Count} —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö –ø–æ–¥—Ö–æ–¥—è—â–∏—Ö –ª–æ—Ç–æ–≤", matchingBookIds.Count);

                // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ª–æ—Ç–æ–≤ –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è (—á—Ç–æ–±—ã –Ω–µ —Å–ø–∞–º–∏—Ç—å)
                var testBookIds = matchingBookIds.Take(request?.MaxBooks ?? 10).ToList();
                
                // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
                var notificationsCreated = await bookNotificationService.ProcessNotificationsForNewBooksAsync(testBookIds);

                _logger.LogInformation("–°–æ–∑–¥–∞–Ω–æ {Count} —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π –¥–ª—è {BookCount} –∫–Ω–∏–≥", notificationsCreated, testBookIds.Count);

                return Ok(new 
                { 
                    success = true, 
                    message = $"–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ. –°–æ–∑–¥–∞–Ω–æ {notificationsCreated} —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π –¥–ª—è {testBookIds.Count} –∫–Ω–∏–≥",
                    details = new 
                    {
                        totalActivePreferences = activePreferences.Count,
                        usersWithTelegram = activePreferences.Count,
                        activeLotsFound = activeLots.Count,
                        uniqueMatchingLots = matchingBookIds.Count,
                        processedBooks = testBookIds.Count,
                        notificationsCreated = notificationsCreated,
                        userMatches = matchedCounts,
                        processedBookIds = testBookIds
                    }
                });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–∏ —Å–∏—Å—Ç–µ–º—ã —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π");
                return StatusCode(500, new 
                { 
                    success = false, 
                    error = "–û—à–∏–±–∫–∞ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è —Å–∏—Å—Ç–µ–º—ã —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π", 
                    message = ex.Message 
                });
            }
        }

        /// <summary>
        /// –§–∏–ª—å—Ç—Ä—É–µ—Ç –∫–Ω–∏–≥–∏ –ø–æ –∫—Ä–∏—Ç–µ—Ä–∏—è–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (–∞–Ω–∞–ª–æ–≥–∏—á–Ω–æ –∫–æ–º–∞–Ω–¥–µ /lots)
        /// </summary>
        private List<RegularBaseBook> FilterBooksByPreferences(List<RegularBaseBook> books, UserNotificationPreference preferences)
        {
            var result = books.AsEnumerable();

            // –§–∏–ª—å—Ç—Ä –ø–æ –∫–ª—é—á–µ–≤—ã–º —Å–ª–æ–≤–∞–º
            var keywords = preferences.GetKeywordsList();
            if (keywords.Any())
            {
                result = result.Where(book =>
                {
                    var title = book.NormalizedTitle?.ToLower() ?? book.Title?.ToLower() ?? "";
                    var description = book.NormalizedDescription?.ToLower() ?? book.Description?.ToLower() ?? "";
                    var tags = book.Tags != null ? string.Join(" ", book.Tags).ToLower() : "";

                    return keywords.Any(keyword => 
                        title.Contains(keyword) || 
                        description.Contains(keyword) || 
                        tags.Contains(keyword));
                });
            }

            // –§–∏–ª—å—Ç—Ä –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º
            var categoryIds = preferences.GetCategoryIdsList();
            if (categoryIds.Any())
            {
                result = result.Where(book => categoryIds.Contains(book.CategoryId));
            }

            // –§–∏–ª—å—Ç—Ä –ø–æ —Ü–µ–Ω–µ
            if (preferences.MinPrice > 0)
            {
                result = result.Where(book => (decimal)book.Price >= preferences.MinPrice);
            }
            if (preferences.MaxPrice > 0)
            {
                result = result.Where(book => (decimal)book.Price <= preferences.MaxPrice);
            }

            // –§–∏–ª—å—Ç—Ä –ø–æ –≥–æ–¥—É –∏–∑–¥–∞–Ω–∏—è
            if (preferences.MinYear > 0)
            {
                result = result.Where(book => book.YearPublished >= preferences.MinYear);
            }
            if (preferences.MaxYear > 0)
            {
                result = result.Where(book => book.YearPublished <= preferences.MaxYear);
            }

            // –§–∏–ª—å—Ç—Ä –ø–æ –≥–æ—Ä–æ–¥–∞–º
            var cities = preferences.GetCitiesList();
            if (cities.Any())
            {
                result = result.Where(book =>
                {
                    var bookCity = book.City?.ToLower() ?? "";
                    return cities.Any(city => bookCity.Contains(city));
                });
            }

            return result.ToList();
        }
    }

    /// <summary>
    /// –ú–æ–¥–µ–ª—å –∑–∞–ø—Ä–æ—Å–∞ –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π
    /// </summary>
    public class TestNotificationsRequest
    {
        /// <summary>
        /// –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–Ω–∏–≥ –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 10)
        /// </summary>
        public int? MaxBooks { get; set; } = 10;

        /// <summary>
        /// –¢–æ–ª—å–∫–æ –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (–ø–æ email)
        /// </summary>
        public string? UserEmail { get; set; }
    }
}
